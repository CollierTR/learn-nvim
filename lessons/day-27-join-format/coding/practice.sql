-- PostgreSQL Practice: Long Queries to Format
-- Day 27: Practice with J (join lines), gq (format), and gw (format/wrap)
-- These queries need line joining and formatting practice

-- SECTION 1: Over-broken SELECT statement - Use J to join lines appropriately
SELECT
customer_id,
first_name,
last_name,
email_address,
phone_number,
street_address,
city,
state,
postal_code,
country,
registration_date,
last_login_date,
account_status,
loyalty_tier,
total_orders,
lifetime_value
FROM
customer_master_view
WHERE
account_status
=
'ACTIVE'
AND
registration_date
>=
'2023-01-01'
AND
loyalty_tier
IN
(
'GOLD',
'PLATINUM',
'DIAMOND'
)
ORDER
BY
lifetime_value
DESC,
registration_date
ASC;

-- SECTION 2: Extremely long single line - Use gq to format and wrap properly
SELECT c.customer_id, c.first_name, c.last_name, c.email, o.order_id, o.order_date, o.order_total, p.product_name, od.quantity, od.unit_price, od.total_line_amount, cat.category_name, s.supplier_name, ship.shipping_method, ship.tracking_number, ship.estimated_delivery_date FROM customers c INNER JOIN orders o ON c.customer_id = o.customer_id INNER JOIN order_details od ON o.order_id = od.order_id INNER JOIN products p ON od.product_id = p.product_id INNER JOIN categories cat ON p.category_id = cat.category_id INNER JOIN suppliers s ON p.supplier_id = s.supplier_id LEFT JOIN shipments ship ON o.order_id = ship.order_id WHERE o.order_status = 'COMPLETED' AND o.order_date >= CURRENT_DATE - INTERVAL '90 days' AND c.customer_status = 'ACTIVE' AND p.product_status = 'AVAILABLE' ORDER BY o.order_date DESC, o.order_total DESC;

-- SECTION 3: Inconsistent line breaks in CTE - Practice with J and formatting
WITH
monthly_sales_summary
AS
(
SELECT
DATE_TRUNC('month', order_date)
as
sales_month,
COUNT(DISTINCT order_id)
as
total_orders,
COUNT(DISTINCT customer_id)
as
unique_customers,
SUM(order_total)
as
monthly_revenue,
AVG(order_total)
as
average_order_value,
MIN(order_total)
as
minimum_order,
MAX(order_total)
as
maximum_order,
STDDEV(order_total)
as
order_value_stddev
FROM
orders
WHERE
order_status
=
'COMPLETED'
AND
order_date
>=
CURRENT_DATE
-
INTERVAL
'24 months'
GROUP
BY
DATE_TRUNC('month', order_date)
),
growth_analysis
AS
(
SELECT
sales_month,
total_orders,
monthly_revenue,
LAG(monthly_revenue)
OVER
(
ORDER
BY
sales_month
)
as
previous_month_revenue,
(
monthly_revenue
-
LAG(monthly_revenue)
OVER
(
ORDER
BY
sales_month
)
)
/
NULLIF(
LAG(monthly_revenue)
OVER
(
ORDER
BY
sales_month
),
0
)
*
100
as
revenue_growth_percentage
FROM
monthly_sales_summary
)
SELECT
TO_CHAR(sales_month, 'YYYY-MM')
as
month,
total_orders,
ROUND(monthly_revenue, 2)
as
revenue,
ROUND(revenue_growth_percentage, 2)
as
growth_rate
FROM
growth_analysis
ORDER
BY
sales_month
DESC;

-- SECTION 4: Function definition with awkward breaks - Use J to clean up
CREATE
OR
REPLACE
FUNCTION
calculate_customer_lifetime_value
(
customer_id_param
INTEGER,
analysis_period_days
INTEGER
DEFAULT
365
)
RETURNS
TABLE
(
customer_id
INTEGER,
total_orders
BIGINT,
total_revenue
DECIMAL,
average_order_value
DECIMAL,
first_order_date
DATE,
last_order_date
DATE,
customer_lifespan_days
INTEGER,
predicted_future_value
DECIMAL
)
AS
$$
BEGIN
RETURN
QUERY
SELECT
o.customer_id,
COUNT(o.order_id)
as
total_orders,
SUM(o.order_total)
as
total_revenue,
AVG(o.order_total)
as
average_order_value,
MIN(o.order_date)::DATE
as
first_order_date,
MAX(o.order_date)::DATE
as
last_order_date,
EXTRACT(DAYS FROM (MAX(o.order_date) - MIN(o.order_date)))::INTEGER
as
customer_lifespan_days,
CASE
WHEN
COUNT(o.order_id)
>
1
AND
EXTRACT(DAYS FROM (MAX(o.order_date) - MIN(o.order_date)))
>
0
THEN
(
SUM(o.order_total)
/
EXTRACT(DAYS FROM (MAX(o.order_date) - MIN(o.order_date)))
)
*
365
ELSE
SUM(o.order_total)
END
as
predicted_future_value
FROM
orders
o
WHERE
o.customer_id
=
customer_id_param
AND
o.order_status
=
'COMPLETED'
AND
o.order_date
>=
CURRENT_DATE
-
INTERVAL
'1 day'
*
analysis_period_days
GROUP
BY
o.customer_id;
END;
$$
LANGUAGE
plpgsql;

-- SECTION 5: UPDATE statement with broken formatting
UPDATE
product_inventory
SET
stock_quantity
=
stock_quantity
+
incoming_quantity,
last_restock_date
=
CURRENT_DATE,
restock_source
=
'SUPPLIER_SHIPMENT',
average_cost
=
(
(
stock_quantity
*
average_cost
)
+
(
incoming_quantity
*
unit_cost
)
)
/
(
stock_quantity
+
incoming_quantity
),
last_updated_by
=
'SYSTEM_AUTO_UPDATE',
last_updated_timestamp
=
CURRENT_TIMESTAMP
WHERE
product_id
IN
(
SELECT
DISTINCT
product_id
FROM
purchase_order_details
WHERE
purchase_order_id
=
current_po_number
AND
received_quantity
>
0
AND
received_date
=
CURRENT_DATE
)
AND
is_active
=
true
AND
allow_inventory_updates
=
true;

-- SECTION 6: Complex CASE statement broken across too many lines
SELECT
order_id,
customer_id,
order_total,
shipping_cost,
CASE
WHEN
order_total
>=
1000
AND
shipping_cost
>
25
THEN
'HIGH_VALUE_EXPENSIVE_SHIPPING'
WHEN
order_total
>=
1000
AND
shipping_cost
<=
25
THEN
'HIGH_VALUE_REASONABLE_SHIPPING'
WHEN
order_total
>=
500
AND
order_total
<
1000
AND
shipping_cost
>
15
THEN
'MEDIUM_VALUE_EXPENSIVE_SHIPPING'
WHEN
order_total
>=
500
AND
order_total
<
1000
AND
shipping_cost
<=
15
THEN
'MEDIUM_VALUE_REASONABLE_SHIPPING'
WHEN
order_total
>=
100
AND
order_total
<
500
AND
shipping_cost
>
10
THEN
'LOW_VALUE_EXPENSIVE_SHIPPING'
WHEN
order_total
>=
100
AND
order_total
<
500
AND
shipping_cost
<=
10
THEN
'LOW_VALUE_REASONABLE_SHIPPING'
ELSE
'VERY_LOW_VALUE_ORDER'
END
as
order_shipping_category,
CASE
WHEN
order_total
>=
1000
THEN
0.15
WHEN
order_total
>=
500
THEN
0.10
WHEN
order_total
>=
250
THEN
0.05
WHEN
order_total
>=
100
THEN
0.02
ELSE
0.00
END
as
loyalty_points_rate
FROM
orders
WHERE
order_status
IN
(
'COMPLETED',
'SHIPPED',
'DELIVERED'
)
AND
order_date
>=
CURRENT_DATE
-
INTERVAL
'1 year';

-- SECTION 7: Window function with excessive line breaks
SELECT
product_id,
product_name,
order_date,
quantity_sold,
revenue,
ROW_NUMBER()
OVER
(
PARTITION
BY
product_id
ORDER
BY
order_date
DESC
)
as
recent_sale_rank,
RANK()
OVER
(
PARTITION
BY
DATE_TRUNC('month', order_date)
ORDER
BY
revenue
DESC
)
as
monthly_revenue_rank,
DENSE_RANK()
OVER
(
ORDER
BY
quantity_sold
DESC
)
as
overall_quantity_rank,
LAG(revenue, 1)
OVER
(
PARTITION
BY
product_id
ORDER
BY
order_date
)
as
previous_sale_revenue,
LEAD(order_date, 1)
OVER
(
PARTITION
BY
product_id
ORDER
BY
order_date
)
as
next_sale_date,
SUM(revenue)
OVER
(
PARTITION
BY
product_id
ORDER
BY
order_date
ROWS
BETWEEN
UNBOUNDED
PRECEDING
AND
CURRENT
ROW
)
as
cumulative_product_revenue,
AVG(quantity_sold)
OVER
(
PARTITION
BY
DATE_TRUNC('week', order_date)
ORDER
BY
order_date
ROWS
BETWEEN
3
PRECEDING
AND
3
FOLLOWING
)
as
weekly_avg_quantity
FROM
product_sales_view
WHERE
order_date
>=
CURRENT_DATE
-
INTERVAL
'6 months'
ORDER
BY
product_id,
order_date
DESC;

-- SECTION 8: Complex INSERT with VALUES broken awkwardly
INSERT
INTO
customer_preferences
(
customer_id,
preference_category,
preference_value,
preference_weight,
last_updated
)
VALUES
(
12345,
'COMMUNICATION_METHOD',
'EMAIL',
0.8,
CURRENT_TIMESTAMP
),
(
12345,
'COMMUNICATION_FREQUENCY',
'WEEKLY',
0.6,
CURRENT_TIMESTAMP
),
(
12345,
'PRODUCT_CATEGORY_INTEREST',
'ELECTRONICS',
0.9,
CURRENT_TIMESTAMP
),
(
12345,
'PRICE_SENSITIVITY',
'MEDIUM',
0.7,
CURRENT_TIMESTAMP
),
(
12345,
'BRAND_PREFERENCE',
'PREMIUM',
0.5,
CURRENT_TIMESTAMP
),
(
12345,
'SHIPPING_PREFERENCE',
'EXPRESS',
0.8,
CURRENT_TIMESTAMP
),
(
12345,
'PAYMENT_METHOD',
'CREDIT_CARD',
0.9,
CURRENT_TIMESTAMP
);

-- SECTION 9: Subquery with poor line distribution
SELECT
c.customer_id,
c.customer_name,
c.registration_date,
(
SELECT
COUNT(*)
FROM
orders
o
WHERE
o.customer_id
=
c.customer_id
AND
o.order_status
=
'COMPLETED'
)
as
completed_orders,
(
SELECT
SUM(order_total)
FROM
orders
o
WHERE
o.customer_id
=
c.customer_id
AND
o.order_status
=
'COMPLETED'
AND
o.order_date
>=
CURRENT_DATE
-
INTERVAL
'1 year'
)
as
annual_spending,
(
SELECT
product_name
FROM
products
p
JOIN
order_details
od
ON
p.product_id
=
od.product_id
JOIN
orders
o
ON
od.order_id
=
o.order_id
WHERE
o.customer_id
=
c.customer_id
AND
o.order_status
=
'COMPLETED'
GROUP
BY
p.product_id,
p.product_name
ORDER
BY
SUM(od.quantity
*
od.unit_price)
DESC
LIMIT
1
)
as
top_purchased_product
FROM
customers
c
WHERE
c.customer_status
=
'ACTIVE'
AND
c.registration_date
>=
'2022-01-01'
ORDER
BY
annual_spending
DESC
NULLS
LAST;

-- SECTION 10: Final challenge - extremely long and broken query
WITH customer_order_summary AS ( SELECT c.customer_id, c.first_name || ' ' || c.last_name as full_name, c.email, c.registration_date, c.loyalty_tier, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.order_total) as lifetime_value, AVG(o.order_total) as avg_order_value, MIN(o.order_date) as first_order, MAX(o.order_date) as last_order, EXTRACT(DAYS FROM (MAX(o.order_date) - MIN(o.order_date))) as customer_lifespan_days, COUNT(DISTINCT DATE_TRUNC('month', o.order_date)) as active_months FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id AND o.order_status = 'COMPLETED' WHERE c.registration_date >= '2020-01-01' GROUP BY c.customer_id, c.first_name, c.last_name, c.email, c.registration_date, c.loyalty_tier ), product_preferences AS ( SELECT o.customer_id, cat.category_name, SUM(od.quantity * od.unit_price) as category_spending, COUNT(DISTINCT od.product_id) as unique_products_in_category, RANK() OVER (PARTITION BY o.customer_id ORDER BY SUM(od.quantity * od.unit_price) DESC) as category_rank FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id JOIN categories cat ON p.category_id = cat.category_id WHERE o.order_status = 'COMPLETED' GROUP BY o.customer_id, cat.category_name ), top_categories AS ( SELECT customer_id, STRING_AGG(category_name, ', ' ORDER BY category_rank) FILTER (WHERE category_rank <= 3) as top_3_categories FROM product_preferences GROUP BY customer_id ) SELECT cos.customer_id, cos.full_name, cos.email, cos.loyalty_tier, cos.total_orders, ROUND(cos.lifetime_value, 2) as lifetime_value, ROUND(cos.avg_order_value, 2) as avg_order_value, cos.first_order, cos.last_order, cos.customer_lifespan_days, cos.active_months, tc.top_3_categories, CASE WHEN cos.lifetime_value >= 10000 AND cos.total_orders >= 20 THEN 'VIP_FREQUENT' WHEN cos.lifetime_value >= 5000 AND cos.total_orders >= 10 THEN 'HIGH_VALUE' WHEN cos.lifetime_value >= 1000 AND cos.total_orders >= 5 THEN 'GOOD_CUSTOMER' WHEN cos.total_orders >= 2 THEN 'REPEAT_CUSTOMER' ELSE 'ONE_TIME_BUYER' END as customer_segment FROM customer_order_summary cos LEFT JOIN top_categories tc ON cos.customer_id = tc.customer_id WHERE cos.total_orders > 0 ORDER BY cos.lifetime_value DESC, cos.total_orders DESC;

-- Practice Instructions:
-- 1. Use J to join lines that are unnecessarily broken
-- 2. Use gq on selected text to format and wrap long lines
-- 3. Use gw to format while preserving cursor position
-- 4. Practice with visual mode: select text then gq
-- 5. Use :set textwidth=80 to control line wrapping length